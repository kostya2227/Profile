<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–í—ã–±–æ—Ä –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –ø—Ä–æ—Ñ–∏–ª—è</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js" integrity="sha512-a+SUDuwNzXDvz4XrIcXHuCf089/iJAoN4lmrXJg18XnduKK6YlDHNRalv4yd1N40OKI80tFidF+rqTFKGPoWFQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <style>
        * { box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 0; height: 100vh; display: flex; flex-direction: column; }
        
        /* Header */
        header { background: #f8f9fa; border-bottom: 1px solid #ddd; padding: 10px 20px; display: flex; align-items: center; justify-content: space-between; height: 60px; }
        h1 { margin: 0; font-size: 18px; }
        
        /* Layout */
        .workspace { display: flex; flex: 1; overflow: hidden; }

        /* Footer */
        footer { padding: 8px 20px; border-top: 1px solid #eee; background: #fafafa; color: #777; font-size: 12px; }
        footer strong { color: #555; }
        
        /* Sidebar (Tables) */
        .sidebar { width: 300px; border-right: 1px solid #ddd; display: flex; flex-direction: column; background: #fff; }
        .sidebar-header { padding: 10px; border-bottom: 1px solid #eee; background: #f8f9fa; }
        .search-box { width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px; }
        .tables-list { flex: 1; overflow-y: auto; }
        .table-item { padding: 8px 15px; cursor: pointer; border-bottom: 1px solid #f0f0f0; display: flex; align-items: center; }
        .table-item:hover { background-color: #f0f8ff; }
        .table-item.active { background-color: #e6f7ff; border-left: 3px solid #1890ff; }
        .table-name { font-weight: 500; flex: 1; }
        .table-check { margin-right: 10px; }
        
        /* Main Area (Parameters) */
        .main-content { flex: 1; display: flex; flex-direction: column; background: #fff; overflow: hidden; position: relative; }
        .empty-state { padding: 40px; text-align: center; color: #888; position: absolute; top: 0; left: 0; width: 100%; }
        
        #paramsContainer { display: flex; flex-direction: column; height: 100%; width: 100%; }
        
        .params-header { padding: 15px 20px; border-bottom: 1px solid #eee; background: #fff; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; }
        .params-title { font-size: 18px; font-weight: 600; }
        .params-list { flex: 1; overflow-y: auto; padding: 20px; }
        
        /* Groups */
        .group-section { border: 1px solid #e8e8e8; border-radius: 4px; margin-bottom: 16px; }
        .group-header { padding: 10px 15px; background: #fafafa; border-bottom: 1px solid #e8e8e8; display: flex; align-items: center; cursor: pointer; user-select: none; }
        .group-header:hover { background: #f0f0f0; }
        .group-title { font-weight: 600; margin-left: 8px; flex: 1; }
        .group-content { padding: 5px 0; display: none; }
        .group-content.open { display: block; }
        
        /* Parameters */
        .param-item { padding: 8px 15px 8px 40px; display: flex; align-items: center; }
        .param-item:hover { background-color: #f9f9f9; }
        .param-label { margin-left: 10px; flex: 1; }
        .param-id { color: #999; font-size: 0.85em; margin-left: 10px; }

        /* Buttons */
        .btn { padding: 6px 12px; border: 1px solid #d9d9d9; background: #fff; border-radius: 4px; cursor: pointer; font-size: 14px; margin-left: 8px; }
        .btn-primary { background: #1890ff; color: #fff; border-color: #1890ff; }
        .btn-primary:hover { background: #40a9ff; border-color: #40a9ff; }
        
        .hidden { display: none !important; }
        
        /* Inputs */
        .input {
            padding: 6px 10px;
            border: 1px solid #d9d9d9;
            border-radius: 4px;
            font-size: 14px;
            outline: none;
        }
        .input:focus { border-color: #1890ff; box-shadow: 0 0 0 2px rgba(24,144,255,0.15); }
        .input-group { display: inline-flex; align-items: center; gap: 8px; }
        .select { padding: 6px 10px; border: 1px solid #d9d9d9; border-radius: 4px; font-size: 14px; background: #fff; }

        /* Checkbox styling */
        input[type="checkbox"] { transform: scale(1.1); cursor: pointer; }
    </style>
</head>
<body>

<header>
    <div>
        <h1>–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ç–æ—Ä –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤</h1>
        <div style="font-size: 12px; color: #666; margin-top: 4px;" id="fileName">–®–∞–≥ 1: –ó–∞–≥—Ä—É–∑–∏—Ç–µ profile.xml</div>
    </div>
    <div id="actionButtons">
        <input type="file" id="xmlFile" accept=".xml" style="display: none;">
        <input type="file" id="jsonFile" accept=".json" style="display: none;">
        <input type="file" id="jsonFiles" accept=".json" multiple style="display: none;">
        <input type="file" id="md5XmlFile" accept=".xml" style="display: none;">
        
        <!-- Initial button -->
        <button class="btn btn-primary" id="btnLoadXml" onclick="document.getElementById('xmlFile').click()">1. –ó–∞–≥—Ä—É–∑–∏—Ç—å profile.xml</button>
        <button class="btn" onclick="document.getElementById('md5XmlFile').click()" title="–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å MD5 —Ö–µ—à –¥–ª—è XML —Ñ–∞–π–ª–∞">üîê –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å md5</button>
        
        <!-- Hidden by default -->
        <span id="workflowButtons" class="hidden">
            <span style="border-left: 1px solid #ccc; margin: 0 10px;"></span>
            <button class="btn" onclick="document.getElementById('jsonFile').click()">üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç—å –≤—ã–±–æ—Ä –∫–ª–∏–µ–Ω—Ç–∞</button>
            <button class="btn" onclick="document.getElementById('jsonFiles').click()">üìÇüìÇ –ò–º–ø–æ—Ä—Ç –≤—ã–±–æ—Ä–æ–≤ (–Ω–µ—Å–∫–æ–ª—å–∫–æ)</button>
            <select id="mergeMode" class="select" title="–ö–∞–∫ –æ–±—ä–µ–¥–∏–Ω—è—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–∞–π–ª–æ–≤">
                <option value="union">–û–±—ä–µ–¥–∏–Ω–∏—Ç—å (union)</option>
                <option value="intersection">–ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ (intersection)</option>
            </select>
            <button class="btn btn-primary" onclick="exportData()">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤—ã–±–æ—Ä</button>
            <button class="btn" onclick="showReport()" title="–ü—Ä–æ—Å–º–æ—Ç—Ä —Ç–µ–∫—É—â–µ–≥–æ –≤—ã–±–æ—Ä–∞">üëÅÔ∏è</button>
        </span>
    </div>
</header>

<div class="workspace">
    <!-- Sidebar -->
    <div class="sidebar">
        <div class="sidebar-header">
            <input type="text" class="search-box" placeholder="–ü–æ–∏—Å–∫ —Ç–∞–±–ª–∏—Ü—ã..." onkeyup="filterTables(this.value)">
        </div>
        <div class="tables-list" id="tablesList">
            <!-- Tables will be injected here -->
        </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <div id="paramsContainer" class="hidden">
            <div class="params-header">
                <div>
                    <div class="params-title" id="currentTableName">–ù–∞–∑–≤–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã</div>
                    <div style="font-size: 12px; color: #888;" id="currentTableId">ID</div>
                </div>
                <div>
                    <span class="input-group" style="margin-right: 10px;">
                        <input id="paramSearch" class="input" type="text" placeholder="–ü–æ–∏—Å–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞..." style="width: 260px;" oninput="setParamFilter(this.value)" />
                        <button class="btn" onclick="clearParamFilter()" title="–û—á–∏—Å—Ç–∏—Ç—å –ø–æ–∏—Å–∫">√ó</button>
                    </span>
                    <button class="btn" onclick="toggleAllGroups(true)">–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å –≤—Å–µ</button>
                    <button class="btn" onclick="toggleAllGroups(false)">–°–≤–µ—Ä–Ω—É—Ç—å –≤—Å–µ</button>
                </div>
            </div>
            <div class="params-list" id="paramsList">
                <!-- Parameters/Groups will be injected here -->
            </div>
        </div>
        
        <!-- Report View -->
        <div id="reportContainer" class="hidden" style="height: 100%; display: flex; flex-direction: column;">
            <div class="params-header" style="background: #e6f7ff;">
                <div class="params-title">–û—Ç—á–µ—Ç –ø–æ –≤—ã–±—Ä–∞–Ω–Ω—ã–º –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º</div>
                <button class="btn" onclick="closeReport()">–ó–∞–∫—Ä—ã—Ç—å</button>
            </div>
            <div class="params-list" id="reportContent">
                <!-- Report will be injected here -->
            </div>
        </div>

        <div id="emptyState" class="empty-state">
            –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∞–±–ª–∏—Ü—É –∏–∑ —Å–ø–∏—Å–∫–∞ —Å–ª–µ–≤–∞
        </div>
    </div>
</div>

<footer>
    –†–∞–∑—Ä–∞–±–æ—Ç–∞–ª <strong>–ö–æ–Ω—é—à–∫–∏–Ω –ö–æ–Ω—Å—Ç–∞–Ω—Ç–∏–Ω</strong>.
</footer>

<script>
    let appData = {
        tables: [], // Array of table objects
        selectedTableId: null,
        selections: {}, // Map: TableName -> Set of ParamNames
        paramSearch: ''
    };

    document.getElementById('xmlFile').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        document.getElementById('fileName').textContent = '–†–∞–±–æ—Ç–∞ —Å —Ñ–∞–π–ª–æ–º: ' + file.name;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            parseXML(e.target.result);
            // Show buttons
            document.getElementById('btnLoadXml').classList.add('hidden');
            document.getElementById('workflowButtons').classList.remove('hidden');
            // Reset selection area
            document.getElementById('reportContainer').classList.add('hidden');
            document.getElementById('emptyState').classList.remove('hidden');
        };
        reader.readAsText(file);
    });

    // Handle JSON Import
    document.getElementById('jsonFile').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const data = JSON.parse(e.target.result);
                loadSelection(data);
                // Immediately show report
                showReport();
                // Update title
                const title = document.querySelector('#reportContainer .params-title');
                if (title) title.textContent = '–û—Ç—á–µ—Ç –ø–æ –≤—ã–±–æ—Ä—É –∫–ª–∏–µ–Ω—Ç–∞ (' + file.name + ')';
            } catch(err) {
                alert('–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è JSON: ' + err.message);
            }
        };
        reader.readAsText(file);
        // Reset value to allow reloading same file
        e.target.value = '';
    });

    // Handle Multiple JSON Import (merge)
    document.getElementById('jsonFiles').addEventListener('change', function(e) {
        const files = Array.from(e.target.files || []);
        if (files.length === 0) return;
        if (!appData.tables || appData.tables.length === 0) {
            alert('–°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ profile.xml, –∑–∞—Ç–µ–º –∏–º–ø–æ—Ä—Ç–∏—Ä—É–π—Ç–µ –≤—ã–±–æ—Ä—ã.');
            e.target.value = '';
            return;
        }

        const modeEl = document.getElementById('mergeMode');
        const mergeMode = modeEl ? modeEl.value : 'union';

        Promise.all(files.map(f => readJsonFile(f)))
            .then(jsonArrays => {
                // Convert each file to map table -> Set(params)
                const maps = jsonArrays.map(arr => selectionArrayToMap(arr));
                const merged = mergeSelections(maps, mergeMode);
                // Apply
                appData.selections = merged;
                renderTableList();
                // Show report
                showReport();
                // Update title
                const title = document.querySelector('#reportContainer .params-title');
                if (title) {
                    title.textContent = `–ò—Ç–æ–≥–æ–≤—ã–π –æ—Ç—á–µ—Ç (${mergeMode === 'union' ? '–æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ' : '–ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ'}) ‚Äî —Ñ–∞–π–ª–æ–≤: ${files.length}`;
                }
            })
            .catch(err => {
                alert('–û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞: ' + (err && err.message ? err.message : String(err)));
            })
            .finally(() => {
                // Reset value to allow reloading same files
                e.target.value = '';
            });
    });

    function readJsonFile(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (!Array.isArray(data)) throw new Error(`–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç JSON –≤ —Ñ–∞–π–ª–µ ${file.name}`);
                    resolve(data);
                } catch (err) {
                    reject(err);
                }
            };
            reader.onerror = () => reject(new Error(`–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ñ–∞–π–ª ${file.name}`));
            reader.readAsText(file);
        });
    }

    function selectionArrayToMap(arr) {
        const map = {};
        arr.forEach(item => {
            if (item && item.table && Array.isArray(item.parameters)) {
                map[item.table] = new Set(item.parameters);
            }
        });
        return map;
    }

    function mergeSelections(maps, mode) {
        const result = {};
        if (!maps || maps.length === 0) return result;

        if (mode === 'intersection') {
            // Intersection: only params selected by everyone.
            // Treat missing table as empty (so it will be dropped).
            const allTableNames = new Set();
            maps.forEach(m => Object.keys(m).forEach(t => allTableNames.add(t)));

            for (const tableName of allTableNames) {
                // Start from first map that has this table; if some map doesn't have table -> empty intersection
                let intersect = null;
                for (const m of maps) {
                    const set = m[tableName];
                    if (!set) { intersect = new Set(); break; }
                    if (intersect === null) intersect = new Set(set);
                    else {
                        for (const v of Array.from(intersect)) {
                            if (!set.has(v)) intersect.delete(v);
                        }
                    }
                }
                if (intersect && intersect.size > 0) result[tableName] = intersect;
            }
            return result;
        }

        // Default: union
        maps.forEach(m => {
            for (const [tableName, set] of Object.entries(m)) {
                if (!result[tableName]) result[tableName] = new Set();
                for (const v of set) result[tableName].add(v);
            }
        });
        return result;
    }

    function loadSelection(data) {
        // Reset current selections
        appData.selections = {};
        
        if (!Array.isArray(data)) {
            alert('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞!');
            return;
        }

        data.forEach(item => {
            if (item.table && Array.isArray(item.parameters)) {
                appData.selections[item.table] = new Set(item.parameters);
            }
        });

        // Refresh UI
        renderTableList();
        // Don't alert, just switch to report
    }

    function showReport() {
        const container = document.getElementById('reportContent');
        container.innerHTML = '';
        
        const tablesWithSelection = appData.tables.filter(t => 
            appData.selections[t.id] && appData.selections[t.id].size > 0
        );

        if (tablesWithSelection.length === 0) {
            container.innerHTML = '<div style="text-align:center; color:#888; margin-top:50px;">–ù–∏—á–µ–≥–æ –Ω–µ –≤—ã–±—Ä–∞–Ω–æ</div>';
        } else {
            tablesWithSelection.forEach(table => {
                const selectedSet = appData.selections[table.id];
                
                const tableBlock = document.createElement('div');
                tableBlock.style.marginBottom = '30px';
                tableBlock.innerHTML = `<h3 style="border-bottom: 2px solid #1890ff; padding-bottom: 10px;">${table.caption} <small style="color:#999">(${table.id})</small></h3>`;
                
                const ul = document.createElement('ul');
                ul.style.listStyle = 'none';
                ul.style.padding = '0';
                
                // Iterate groups to maintain order
                table.groups.forEach(group => {
                    const groupParams = group.params.filter(p => selectedSet.has(p.id));
                    if (groupParams.length > 0) {
                        const groupLi = document.createElement('li');
                        groupLi.style.marginTop = '15px';
                        groupLi.innerHTML = `<strong style="color:#555;">${group.name}</strong>`;
                        
                        const subUl = document.createElement('ul');
                        subUl.style.marginTop = '5px';
                        
                        groupParams.forEach(p => {
                            const li = document.createElement('li');
                            li.style.padding = '4px 0';
                            li.style.borderBottom = '1px solid #eee';
                            li.innerHTML = `${p.label} <span style="color:#aaa; font-size:0.8em;">(${p.id})</span>`;
                            subUl.appendChild(li);
                        });
                        
                        groupLi.appendChild(subUl);
                        ul.appendChild(groupLi);
                    }
                });
                
                tableBlock.appendChild(ul);
                container.appendChild(tableBlock);
            });
        }

        document.getElementById('paramsContainer').classList.add('hidden');
        document.getElementById('emptyState').classList.add('hidden');
        document.getElementById('reportContainer').classList.remove('hidden');
    }

    function setParamFilter(value) {
        appData.paramSearch = (value || '').toLowerCase().trim();
        const table = appData.tables.find(t => t.id === appData.selectedTableId);
        if (table) {
            // When filtering, start from top for convenience
            document.getElementById('paramsList').scrollTop = 0;
            renderParams(table);
        }
    }

    function clearParamFilter() {
        appData.paramSearch = '';
        const input = document.getElementById('paramSearch');
        if (input) input.value = '';
        const table = appData.tables.find(t => t.id === appData.selectedTableId);
        if (table) renderParams(table);
    }

    function closeReport() {
        document.getElementById('reportContainer').classList.add('hidden');
        if (appData.selectedTableId) {
            document.getElementById('paramsContainer').classList.remove('hidden');
        } else {
            document.getElementById('emptyState').classList.remove('hidden');
        }
    }

    function parseXML(xmlString) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(xmlString, "text/xml");
        
        // Clear data
        appData.tables = [];
        appData.selections = {};
        
        const tableNodes = doc.querySelectorAll('tables > table');
        
        tableNodes.forEach(node => {
            const root = node.getAttribute('root') === 'true';
            
            // Only add root tables
            if (!root) return;

            const name = node.getAttribute('name');
            const caption = node.getAttribute('caption') || name;
            const position = parseInt(node.getAttribute('position') || '9999');
            
            // Parse columns and organize into groups
            const groups = [];
            let currentGroup = { name: '–û–±—â–∏–µ', params: [] }; // Default group
            
            // Check if first column is group
            const columns = node.querySelectorAll('columns > column');
            
            columns.forEach(col => {
                const colName = col.getAttribute('name');
                const labelNode = col.querySelector('label > value');
                const colLabel = labelNode ? labelNode.textContent : colName;
                const visible = col.getAttribute('visible') !== 'false';
                const internal = col.getAttribute('internal') === 'true';
                
                // Check if this is a group header
                if (colName.startsWith('_GROUP_NAME_')) {
                    // Push previous group if it has items
                    if (currentGroup.params.length > 0) {
                        groups.push(currentGroup);
                    }
                    // Start new group
                    currentGroup = {
                        name: colLabel,
                        params: []
                    };
                } else {
                    // It's a regular parameter
                    currentGroup.params.push({
                        id: colName,
                        label: colLabel,
                        visible: visible,
                        internal: internal
                    });
                }
            });
            
            // Push final group
            if (currentGroup.params.length > 0) {
                groups.push(currentGroup);
            }
            
            appData.tables.push({
                id: name,
                caption: caption,
                root: root,
                position: position,
                groups: groups
            });
        });
        
        renderTableList();
        document.getElementById('emptyState').textContent = '–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∞–±–ª–∏—Ü—É –∏–∑ —Å–ø–∏—Å–∫–∞ —Å–ª–µ–≤–∞';
    }

    function renderTableList() {
        const container = document.getElementById('tablesList');
        container.innerHTML = '';
        
        // Sort by position
        appData.tables.sort((a, b) => a.position - b.position);
        
        appData.tables.forEach(table => {
            const div = document.createElement('div');
            div.className = 'table-item';
            div.dataset.id = table.id;
            div.onclick = () => selectTable(table.id);
            
            // Check state
            const isChecked = appData.selections[table.id] && appData.selections[table.id].size > 0;
            
            div.innerHTML = `
                <div class="table-name">${table.caption}</div>
                <div style="font-size: 10px; color: #999; margin-left: 5px;">${table.id}</div>
            `;
            if (isChecked) {
                div.style.borderLeft = '3px solid #1890ff';
                div.style.background = '#e6f7ff';
            }
            container.appendChild(div);
        });
    }

    function selectTable(tableId) {
        appData.selectedTableId = tableId;
        
        // Update UI active state
        document.querySelectorAll('.table-item').forEach(el => {
            el.classList.toggle('active', el.dataset.id === tableId);
        });
        
        // Show params
        const table = appData.tables.find(t => t.id === tableId);
        if (!table) return;
        
        document.getElementById('currentTableName').textContent = table.caption;
        document.getElementById('currentTableId').textContent = table.id;
        document.getElementById('paramsContainer').classList.remove('hidden');
        document.getElementById('emptyState').classList.add('hidden');

        // Reset param search on table change
        clearParamFilter();
        
        renderParams(table);
    }

    function renderParams(table) {
        const container = document.getElementById('paramsList');
        // Preserve scroll + expanded groups to avoid "jump to top" on rerender
        const prevScrollTop = container.scrollTop;
        const openGroupNames = new Set(
            Array.from(container.querySelectorAll('.group-section')).flatMap(sec => {
                const nameEl = sec.querySelector('.group-title');
                const contentEl = sec.querySelector('.group-content');
                if (!nameEl || !contentEl) return [];
                return contentEl.classList.contains('open') ? [nameEl.textContent] : [];
            })
        );

        container.innerHTML = '';
        
        // Get current selections for this table
        const selectedParams = appData.selections[table.id] || new Set();

        const q = (appData.paramSearch || '').toLowerCase().trim();
        const matches = (param) => {
            if (!q) return true;
            const hay = `${param.label} ${param.id}`.toLowerCase();
            return hay.includes(q);
        };
        
        table.groups.forEach((group, index) => {
            const visibleParams = group.params.filter(matches);
            if (q && visibleParams.length === 0) return; // hide empty groups when filtering

            // Group Container
            const groupDiv = document.createElement('div');
            groupDiv.className = 'group-section';
            
            // Header
            const header = document.createElement('div');
            header.className = 'group-header';
            
            // Group Checkbox (Select All in Group)
            const allChecked = group.params.every(p => selectedParams.has(p.id));
            const someChecked = group.params.some(p => selectedParams.has(p.id));
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = allChecked;
            checkbox.indeterminate = someChecked && !allChecked;
            // Prevent collapsing when interacting with the group checkbox (incl. mobile/edge cases)
            checkbox.addEventListener('pointerdown', (e) => e.stopPropagation());
            checkbox.addEventListener('mousedown', (e) => e.stopPropagation());
            checkbox.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleGroup(table.id, group, checkbox.checked);
            });
            
            header.appendChild(checkbox);
            
            const title = document.createElement('span');
            title.className = 'group-title';
            title.textContent = group.name;
            header.appendChild(title);
            
            const toggleIcon = document.createElement('span');
            toggleIcon.textContent = '‚ñº';
            toggleIcon.style.fontSize = '12px';
            header.appendChild(toggleIcon);
            
            // Content container
            const content = document.createElement('div');
            // Default open, but keep user's previous open/closed choice on rerender
            const shouldBeOpen = q ? true : (openGroupNames.size === 0 ? true : openGroupNames.has(group.name));
            content.className = 'group-content' + (shouldBeOpen ? ' open' : '');
            toggleIcon.textContent = shouldBeOpen ? '‚ñº' : '‚ñ∂';

            // Toggle Logic
            header.onclick = (e) => {
                // If click happened on the checkbox (or any element inside it), do NOT toggle group
                if (e.target && e.target.closest && e.target.closest('input[type="checkbox"]')) return;

                content.classList.toggle('open');
                toggleIcon.textContent = content.classList.contains('open') ? '‚ñº' : '‚ñ∂';
            };

            // Render items (filtered if search is active)
            visibleParams.forEach(param => {
                const pDiv = document.createElement('div');
                pDiv.className = 'param-item';
                
                // Badge for flags
                let badges = '';
                if (!param.visible) badges += '<span style="font-size:9px; background:#eee; padding:2px 4px; border-radius:3px; margin-left:5px; color:#666;">HIDDEN</span>';
                if (param.internal) badges += '<span style="font-size:9px; background:#fff0f6; padding:2px 4px; border-radius:3px; margin-left:5px; color:#c41d7f;">INTERNAL</span>';

                const pCheck = document.createElement('input');
                pCheck.type = 'checkbox';
                pCheck.checked = selectedParams.has(param.id);
                pCheck.onchange = () => toggleParam(table.id, param.id, pCheck.checked);
                
                pDiv.innerHTML = `
                    <label class="param-label" style="display:flex; align-items:center;">
                        ${param.label} 
                        ${badges}
                    </label>
                    <span class="param-id">${param.id}</span>
                `;
                pDiv.prepend(pCheck);
                content.appendChild(pDiv);
            });
            
            groupDiv.appendChild(header);
            groupDiv.appendChild(content);
            container.appendChild(groupDiv);
        });

        // Restore scroll after DOM rebuild (next frame helps in some browsers)
        requestAnimationFrame(() => {
            // If search is active we already forced scrollTop=0 in setParamFilter()
            if (!q) container.scrollTop = prevScrollTop;
        });
    }

    function toggleParam(tableId, paramId, checked) {
        if (!appData.selections[tableId]) {
            appData.selections[tableId] = new Set();
        }
        
        if (checked) {
            appData.selections[tableId].add(paramId);
        } else {
            appData.selections[tableId].delete(paramId);
        }
        
        // Refresh view to update group checkbox states
        const table = appData.tables.find(t => t.id === tableId);
        renderParams(table);
        updateSidebarIndicator(tableId);
    }

    function toggleGroup(tableId, group, checked) {
        if (!appData.selections[tableId]) {
            appData.selections[tableId] = new Set();
        }
        
        group.params.forEach(p => {
            if (checked) appData.selections[tableId].add(p.id);
            else appData.selections[tableId].delete(p.id);
        });
        
        const table = appData.tables.find(t => t.id === tableId);
        renderParams(table);
        updateSidebarIndicator(tableId);
    }

    function updateSidebarIndicator(tableId) {
        // Just for visual "something is selected in this table"
        // This is a bit simplified, ideally we'd re-render the list item
        // But for now, let's just assume users will see the checkbox state inside
    }
    
    function toggleAllGroups(open) {
        document.querySelectorAll('.group-content').forEach(el => {
            if(open) el.classList.add('open');
            else el.classList.remove('open');
        });
    }

    function filterTables(query) {
        query = query.toLowerCase();
        document.querySelectorAll('.table-item').forEach(item => {
            const text = item.innerText.toLowerCase();
            item.style.display = text.includes(query) ? 'flex' : 'none';
        });
    }

    function exportData() {
        const result = [];
        
        for (const [tableId, params] of Object.entries(appData.selections)) {
            if (params.size > 0) {
                result.push({
                    table: tableId,
                    parameters: Array.from(params)
                });
            }
        }
        
        if (result.length === 0) {
            alert('–ù–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤');
            return;
        }
        
        const json = JSON.stringify(result, null, 2);
        const blob = new Blob([json], {type: "application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = "profile_selection.json";
        a.click();
    }

    // Handle MD5 Generation
    document.getElementById('md5XmlFile').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        if (!file.name.toLowerCase().endsWith('.xml')) {
            alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª —Ñ–æ—Ä–º–∞—Ç–∞ .xml');
            e.target.value = '';
            return;
        }
        
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                generateMD5(e.target.result);
            } catch(err) {
                alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ MD5: ' + err.message);
            }
        };
        reader.onerror = function() {
            alert('–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞');
        };
        reader.readAsArrayBuffer(file);
        
        // Reset value to allow reloading same file
        e.target.value = '';
    });

    function generateMD5(arrayBuffer) {
        // Convert ArrayBuffer to WordArray (big-endian 32-bit words)
        const bytes = new Uint8Array(arrayBuffer);
        const words = [];
        
        // Process bytes in chunks of 4 (32-bit words)
        for (let i = 0; i < bytes.length; i += 4) {
            let word = 0;
            // Big-endian: most significant byte first
            for (let j = 0; j < 4; j++) {
                if (i + j < bytes.length) {
                    word |= (bytes[i + j] << (24 - j * 8));
                }
            }
            words.push(word);
        }
        
        const fileWordArray = CryptoJS.lib.WordArray.create(words, bytes.length);
        
        // Add "TRSYS" as UTF-8 bytes (same as Python b"TRSYS")
        const trsysWordArray = CryptoJS.enc.Utf8.parse("TRSYS");
        const combined = fileWordArray.concat(trsysWordArray);
        
        // Calculate MD5 hash
        const hash = CryptoJS.MD5(combined);
        const md5Hex = hash.toString(CryptoJS.enc.Hex).toUpperCase();
        
        // Create and download file
        const blob = new Blob([md5Hex], {type: "text/plain"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = "profile.md5";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
</script>

</body>
</html>
